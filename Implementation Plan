# Codebase Refactoring Plan

The main goal of this plan is to improve the modularity, maintainability, and testability of the Chasm AI Antigravity codebase without changing its external behavior. 

## User Review Required

> [!NOTE]
> Please review these proposed refactoring steps. They are focused on structural improvements and addressing technical debt. No functional changes will be made to the underlying logic.

## Proposed Changes

### Configuration and Path Management
Currently, multiple files (`chasm/api/main.py`, `chasm/workflows/pipeline.py`) use brittle path resolution logic (`Path(__file__).resolve().parents...`) to locate data directories.
- **Goal:** Centralize path configurations using the existing Pydantic models.
- **Details:** 
  - Update `chasm/core/config.py` to include `data_dir`, `reports_dir`, and `export_path` settings using `pydantic-settings` or `os.getenv`.
  - Refactor files to import `settings` instead of resolving paths manually.

### API Routing (FastAPI)
The `chasm/api/main.py` file is growing rapidly and contains all HTTP endpoints, lifespan events, and persistence logic.
- **Goal:** Split routes into logical modules using FastAPI's `APIRouter`.
- **Details:**
  - Create a new directory `chasm/api/routes/`.
  - Extract endpoints into:
    - `routes/products.py`
    - `routes/reports.py`
    - `routes/onboarding.py`
    - `routes/research.py`
  - `chasm/api/main.py` will simply include these routers.

### Graph Persistence
Graph loading and saving (`_load_graph_from_disk`, `_save_graph_to_disk`) are tightly coupled to the FastAPI lifespan events in `chasm/api/main.py`.
- **Goal:** Decouple file I/O from the HTTP layer.
- **Details:**
  - Create `chasm/graph/persistence.py`.
  - Move the logic that interacts with `export.json` into a dedicated `GraphStorage` or `Persistence` class.

### Pipeline Modularity
The weekly research pipeline (`chasm/workflows/pipeline.py::run_weekly_research`) is a monolithic 120-line procedural function. It hand-curates directory creation, orchestration, exception handling, and persistence.
- **Goal:** Break down the pipeline into testable, discrete components.
- **Details:**
  - Refactor into a `WeeklyResearchPipeline` class.
  - Create step-specific methods: `_discover_sources()`, `_scrape_sources()`, `_extract_insights()`, `_build_graph()`, and `_link_semantics()`.

### Test Architecture
Integration testing blocks (e.g., `if __name__ == "__main__":` in `chasm/graph/builder.py` and `chasm/agents/cataloger.py`) are excellent for debugging but clutter production code and are difficult to run sequentially in a CI pipeline.
- **Goal:** Standardize testing.
- **Details:**
  - Create a top-level `tests/` directory (e.g., `tests/integration/`).
  - Move the `__main__` blocks from `builder.py` and `cataloger.py` into proper `pytest` files, e.g., `test_graph_builder.py` and `test_cataloger.py`.

### Frontend Configuration
The React application (`chasm-ui/src/App.tsx`, and likely `api.ts`) hardcodes the backend URL `http://localhost:8000`.
- **Goal:** Make the UI easily deployable.
- **Details:**
  - Replace hardcoded localhost references with environment variables (`import.meta.env.VITE_API_URL`).
  - Extract the manual prompt logic from `App.tsx` (e.g., `window.open(...)`) into proper UI modals or dedicated API calls.

## Verification Plan

### Automated Tests
- Run `pytest tests/` to execute the extracted integration tests.
- Re-run `python main.py --schedule` locally for a short duration to ensure the scheduler and pipeline can still start up.
- Re-run `uvicorn chasm.api.main:app` to ensure the API starts up without errors.

### Manual Verification
- Deploy the frontend locally using `npm run dev` and navigate to the dashboard to ensure it still successfully loads and maps back to the API.
